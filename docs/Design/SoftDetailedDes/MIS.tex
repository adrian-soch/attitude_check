\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{ bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X} \toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
\today 1 & 1.0 & Initial document\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at
\url{https://github.com/adrian-soch/attitude_check/blob/main/docs/SRS/SRS.pdf}.

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname.

Complementary documents include the System Requirement Specifications and Module Guide.  The full
documentation and implementation can be found at
\url{https://github.com/adrian-soch/attitude_check}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995}, with the addition
that template modules have been adapted from \cite{GhezziEtAl2003}.  The mathematical notation comes
from Chapter 3 of \citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1 \Rightarrow r_1 | c_2
\Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname.

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent
\begin{tabular}{l l p{7.5cm}}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\
\midrule
% character & char & a single symbol or digit\\
% integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
% natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & $\mathbb{B}$ & value in $[\text{false}=0, \text{true}=1]$\\
matrix & $\mathbb{R}^{m \times n}$ & matrix of any number in (-$\infty$, $\infty$)\\
vector & $\mathbb{R}^{m}$ & column vector of any number in (-$\infty$, $\infty$)\\
quaternion & $\mathbf{q}$ & a quaternion $\in \mathbb{R}^4$, see SRS for details\\
\bottomrule
\end{tabular}
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and tuples.
Sequences are lists filled with elements of the same data type. Strings are sequences of characters.
Tuples contain a list of values, potentially of different types. In addition, \progname \ uses
functions, which are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

% {Hardware-Hiding Module} & ~ \\
% \midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Control Module \\
& Input Verification Module \\
& Initial Quaternion Estimator w/o Mag Module \\
& Initial Quaternion Estimator w Mag Module \\
& Estimate w/o Mag Module \\
& Estimate w Mag Module \\
\midrule
\multirow{2}{0.3\textwidth}{Software Decision Module} & Matrix Math Module\\
& Quaternion Module \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Control Module} \label{cm}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
  external interaction with the environment, such as for a device driver, screen interface,
  keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Estimate w/o Mag Module} \label{ewomm}

\subsection{Module}


\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Estimate w Mag Module} \label{ewmm}

\subsection{Module}


\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Initial Quaternion Estimator w/o Mag Module} \label{iqewomm}

\subsection{Module}


\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Initial Quaternion Estimator w Mag Module} \label{iqewmm}

\subsection{Module}


\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Input Verification Module} \label{ivm}

\subsection{Module}
Input

\subsection{Uses}
Quaternion Module

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
 & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate}
\item output: \wss{if appropriate}
\item exception: \wss{if appropriate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Quaternion Module} \label{qm}

\subsection{Module}
Quaternion

\subsection{Uses}
Matrix Math Module

\subsection{Syntax}

% \subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{6cm} p{2cm} p{1.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
create\_quat & w:=$\mathbb{R}, x:=\mathbb{R}, y:=\mathbb{R}, z:=\mathbb{R}$ & - &
ValueError \\
quat\_prod & $P:=\mathbf{q},  q:=\mathbf{q}$ & $q_\text{out}:=\mathbf{q}$ & - \\
normalize & - & - & - \\
assert\_is\_norm & w:=$\mathbb{R}, x:=\mathbb{R}, y:=\mathbb{R}, z:=\mathbb{R}$ & out$:=\mathbb{B}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

$\text{quat}: \mathbf{q}$

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for practical
  purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent create\_quat($w, x, y, z$):
\begin{itemize}
\item transition: quat $:= \mathbf{q}$ where $\mathbf{q} = [w, x, y, z]$
% \item output: $\t\mathbf{q}$
\item exception: ValueError when  $|\text{quat}| \neq 1$
\end{itemize}

\noindent quat\_prod($p, q$):
\begin{itemize}
% \item transition: \wss{if appropriate}
\item output:
  \begin{align*}
    q_\text{out} :=  \begin{bmatrix}
      p_w q_w - p_x q_x - p_y q_y - p_z q_z \\
      p_w q_x + p_x q_w + p_y q_z - p_z q_y \\
      p_w q_y - p_x q_z + p_y q_w + p_z q_x \\
      p_w q_z + p_x q_y - p_y q_x + p_z q_w
  \end{bmatrix}
  \end{align*}

\item exception: none
\end{itemize}


\noindent normalize():
\begin{itemize}
\item transition: quat $:= \left[ \cfrac{\text{quat}_w}{d}, \cfrac{\text{quat}_x}{d}, \cfrac{\text{quat}_y}{d}, \cfrac{\text{quat}_z}{d} \right]$ where $d = \sqrt{\text{quat}_w^2 + \text{quat}_x^2 + \text{quat}_y^2 + \text{quat}_z^2}$
% \item output: $\mathbf{q}$
\item exception: none
\end{itemize}

\noindent assert\_is\_norm():
\begin{itemize}
\item output: out$:= (1 == \sqrt{w^2 + x^2 + y^2 + z^2})$
\item exception: none
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to have a state
  transition.  In this case a state transition can only occur if the module is changing the state of
  another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you will have one or the
  other.}

% \subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Matrix Math Module} \label{mmm}

\subsection{Module}
Math

\subsection{Uses}
N/A

\subsection{Syntax}

% \subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{3cm} p{2.5cm} p{4.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
* & $\mathbb{R}^{m \times n} \times \mathbb{R}^{n \times m}$ & $m:=\mathbb{R}^{n \times n}$ &
EIGEN\_STATIC\_ASSERT\_ERROR \\
* & $\mathbb{R}^{m \times n} \times \mathbb{R}$ & $m:=\mathbb{R}^{m \times n}$ &
EIGEN\_STATIC\_ASSERT\_ERROR \\
+ & $\mathbb{R}^{m \times n} \times \mathbb{R}^{m \times n}$ & $m:=\mathbb{R}^{m \times n}$ &
EIGEN\_STATIC\_ASSERT\_ERROR \\
% - & $\mathbb{R}^{m \times n} \times \mathbb{R}^{m \times n}$ & $\mathbb{R}^{m \times n}$ &
%   EIGEN\_STATIC\_ASSERT\_ERROR \\
transpose & $\mathbb{R}^{m \times n}$ & $m:=\mathbb{R}^{n \times m}$ & EIGEN\_STATIC\_ASSERT\_ERROR \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\wss{Not all modules will have state variables.  State variables give the module a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture when the module has
%   external interaction with the environment, such as for a device driver, screen interface,
%   keyboard, file, etc.}

% \subsubsection{Assumptions}

% \wss{Try to minimize assumptions and anticipate programmer errors via exceptions, but for
%   practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent transpose($\mathbb{R}^{m \times n}$):
\begin{itemize}
% \item transition: \wss{if appropriate}
\item output: $m:=\mathbb{R}^{m \times n}$
\item exception: EIGEN\_STATIC\_ASSERT\_ERROR
\end{itemize}

$[\mathbf{A}^T]_{i,j} = [\mathbf{A}]_{j,i}$
\newline

\noindent $\mathbb{R}^{m \times n} * \mathbb{R}^{n \times m}$:
\begin{itemize}
% \item transition: \wss{if appropriate}
\item output: $m:=\mathbb{R}^{n \times n}$
\item exception: EIGEN\_STATIC\_ASSERT\_ERROR
\end{itemize}

Let $\mathbf{A} = [a_{i,j}]_{m\times n}$ and $\mathbf{B} = [b_{i,j}]_{n\times m}$. Then $\mathbf{C} = \mathbf{A} * \mathbf{B}$ with $c_{i,j} = a_{i,0} b_{0,j} + a_{i,1} b_{1,j} ...  a_{i,n}b_{n,j}$.
\newline

\noindent $\mathbb{R}^{m \times n} * \mathbb{R}$:
\begin{itemize}
% \item transition: \wss{if appropriate}
\item output: $m:=\mathbb{R}^{m \times n}$
\item exception: EIGEN\_STATIC\_ASSERT\_ERROR
\end{itemize}

Let $\mathbf{A} = [a_{i,j}]_{m\times n}$ and $k = \mathbb{R}$. Then $\mathbf{C} = \mathbf{A} * k$ with $c_{i,j} = k a_{i,j}$.
\newline

\noindent $\mathbb{R}^{m \times n} + \mathbb{R}^{m \times n}$:
\begin{itemize}
% \item transition: \wss{if appropriate}
\item output: $m:=\mathbb{R}^{m \times n}$
\item exception: EIGEN\_STATIC\_ASSERT\_ERROR
\end{itemize}

Let $\mathbf{A} = [a_{i,j}]_{m \times n}$ and $\mathbf{B} = [b_{i,j}]_{m \times n}$. Then $\mathbf{A} + \mathbf{B}
= [a_{i,j} + b_{i,j}]_{m \times n}$.

% \subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification. They are not
  necessarily something that is going to be implemented explicitly.  Even if they are implemented,
  they are not exported; they only have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

% \newpage \section{Appendix} \label{Appendix}

\wss{Extra information if required}



\end{document}
